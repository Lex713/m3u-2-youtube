<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>M3U â†’ YouTube Playlist</title>
  <style>
    :root{
      --bg:#ffffff; --fg:#111827; --muted:#6b7280; --card:#f3f4f6; --accent:#0ea5a4; --danger:#ef4444; --glass:rgba(0,0,0,0.04)
    }
    @media (prefers-color-scheme: dark){
      :root{ --bg:#0b1220; --fg:#e6eef8; --muted:#9aa4b2; --card:#0f1724; --accent:#22c1c3; --danger:#ff6b6b; --glass:rgba(255,255,255,0.03) }
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Arial}
    .container{max-width:980px;margin:20px auto;padding:18px}
    h1{margin:0 0 8px;font-weight:600}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .card{background:var(--card);padding:12px;border-radius:10px;box-shadow:0 1px 0 var(--glass);margin-top:12px}
    label{font-size:13px;color:var(--muted)}
    input[type=file]{padding:6px}
    textarea{width:100%;height:120px;font-family:monospace}
    select,input[type=number],input[type=text]{padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);min-width:120px}
    button{padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:white;cursor:pointer}
    button.ghost{background:transparent;color:var(--fg);border:1px solid rgba(0,0,0,0.06)}
    .log{white-space:pre-wrap;background:transparent;padding:8px;border-radius:6px;max-height:320px;overflow:auto;font-family:monospace}
    table{width:100%;border-collapse:collapse;margin-top:8px}
    td,th{border-bottom:1px solid rgba(0,0,0,0.06);padding:6px;text-align:left;font-size:13px}
    .muted{color:var(--muted)}
    .small{font-size:13px}
    .flex{display:flex;gap:8px;align-items:center}
  </style>
</head>
<body>
  <div class="container">
    <h1>M3U â†’ YouTube Playlist</h1>
    <div class="card">
      <div class="row">
        <div style="flex:1">
          <div class="small muted">Google OAuth Client ID (paste your project's Web OAuth Client ID) â€” stored only in your browser</div>
          <input id="clientIdInput" type="text" placeholder="CLIENT_ID.apps.googleusercontent.com" style="width:*90%" />
        </div>
        <div style="width:30%">
          <div class="small muted">Optional API Key (search quota separated)</div>
          <input id="apiKeyInput" type="text" placeholder="Optional: API Key" />
        </div>
      </div>
      <div style="margin-top:8px" class="row">
        <div>
          <label class="muted">Trim leading path segments</label><br />
          <input id="trimSegments" type="number" min="0" value="2" />
        </div>
        <div>
          <label class="muted">Batch size (searches group)</label><br />
          <select id="batchSize">
            <option value="5">5</option>
            <option value="10" selected>10</option>
            <option value="20">20</option>
            <option value="50">50</option>
          </select>
        </div>
        <div>
          <label class="muted">Cache lifetime</label><br />
          <select id="cacheLifetime">
            <option value="0">Forever</option>
            <option value="1">1 day</option>
            <option value="7" selected>7 days</option>
            <option value="30">30 days</option>
          </select>
        </div>
        <div>
          <label class="muted">Playlist privacy</label><br />
          <select id="privacySelect">
            <option value="private" selected>Private</option>
            <option value="unlisted">Unlisted</option>
            <option value="public">Public</option>
          </select>
        </div>
      </div>

      <div style="margin-top:12px" class="row">
        <input id="fileInput" type="file" accept=".m3u,.txt" />
        <button id="parseBtn">Parse M3U</button>
        <button id="authorizeBtn">Authorize with Google</button>
        <button id="createPlaylistBtn" disabled>Create playlist from parsed tracks</button>
        <button id="clearCacheBtn" class="ghost">Clear cache</button>
      </div>

      <div id="quotaInfo" style="margin-top:12px" class="muted small">Loading quota info...</div>
    </div>

    <div class="card" style="margin-top:14px">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <strong>Tracks parsed</strong>
          <div id="tracksCount" class="muted small">0 tracks</div>
        </div>
        <div class="muted small">Tip: batch size affects quota â€” larger batches use fewer search units per song but may reduce match accuracy.</div>
      </div>

      <div id="tracksArea" style="margin-top:8px"></div>
    </div>

    <div class="card">
      <strong>Progress & Log</strong>
      <div id="progress" class="muted small">Idle</div>
      <div id="log" class="log"></div>
    </div>

    <div class="card" style="margin-top:12px">
      <strong>Notes</strong>
      <ul class="muted small">
        <li>This runs entirely in your browser. Keep your OAuth client and API key private â€” they are stored only in localStorage of your browser.</li>
        <li>Batching: the app groups up to <em>Batch size</em> queries into a single search request to conserve quota.</li>
        <li>Quota units used are estimated; real quotas come from Google and may vary. The page resets quota tracking at midnight CTD (America/Chicago, UTCâˆ’5/âˆ’6 depending on DST).</li>
      </ul>
    </div>

  </div>

<script>
// Silly Goofy JS goes hereee 
// ------------ Configuration ------------
const DAILY_QUOTA = 10000;
const SEARCH_COST = 100;        // per search.list call
const INSERT_COST = 50;         // per playlistItems.insert call
const PLAYLIST_COST = 50;       // per playlists.insert call
const CTD_TIMEZONE = 'America/Chicago'; // CTD / UTC-5 baseline for reset display

// ------------- App state -------------
let accessToken = null;
let tokenClient = null;
let parsedTracks = []; // {orig, query}
let clientId = '';
let apiKey = '';

// DOM ðŸ‘‰ðŸ‘ˆ
const fileInput = document.getElementById('fileInput');
const parseBtn = document.getElementById('parseBtn');
const trimSegmentsEl = document.getElementById('trimSegments');
const tracksArea = document.getElementById('tracksArea');
const authorizeBtn = document.getElementById('authorizeBtn');
const createPlaylistBtn = document.getElementById('createPlaylistBtn');
const logEl = document.getElementById('log');
const progressEl = document.getElementById('progress');
const quotaInfoEl = document.getElementById('quotaInfo');
const clientIdInput = document.getElementById('clientIdInput');
const apiKeyInput = document.getElementById('apiKeyInput');
const batchSizeSelect = document.getElementById('batchSize');
const cacheLifetimeSelect = document.getElementById('cacheLifetime');
const privacySelect = document.getElementById('privacySelect');
const tracksCountEl = document.getElementById('tracksCount');
const clearCacheBtn = document.getElementById('clearCacheBtn');

function log(...args){
  const line = args.map(a=>typeof a==='object'?JSON.stringify(a):String(a)).join(' ');
  logEl.textContent += line + '\n';
  logEl.scrollTop = logEl.scrollHeight;
  console.log(...args);
}

// ---------------- Storage utils ----------------
function saveSettings(){
  localStorage.setItem('m3u_client_id', clientIdInput.value || '');
  localStorage.setItem('m3u_api_key', apiKeyInput.value || '');
  localStorage.setItem('m3u_batch_size', batchSizeSelect.value);
  localStorage.setItem('m3u_cache_lifetime', cacheLifetimeSelect.value);
  localStorage.setItem('m3u_privacy', privacySelect.value);
}
function loadSettings(){
  clientIdInput.value = localStorage.getItem('m3u_client_id') || '';
  apiKeyInput.value = localStorage.getItem('m3u_api_key') || '';
  batchSizeSelect.value = localStorage.getItem('m3u_batch_size') || '10';
  cacheLifetimeSelect.value = localStorage.getItem('m3u_cache_lifetime') || '7';
  privacySelect.value = localStorage.getItem('m3u_privacy') || 'private';
}
loadSettings();

// Cache structure: one object stored under 'm3u_yt_cache_v2'
function loadCache(){
  try{ return JSON.parse(localStorage.getItem('m3u_yt_cache_v2')||'{}'); }catch(e){ return {}; }
}
function saveCache(cache){ localStorage.setItem('m3u_yt_cache_v2', JSON.stringify(cache)); }

function clearCache(){ localStorage.removeItem('m3u_yt_cache_v2'); log('Cache cleared'); updateQuotaDisplay(); }
clearCacheBtn.addEventListener('click', ()=>{ clearCache(); renderTracks(); });

// ---------------- Quota tracking ----------------
function quotaKeyForToday(){
  // compute date string in CTD timezone (YYYY-MM-DD)
  const now = new Date();
  const parts = now.toLocaleString('en-CA',{timeZone:CTD_TIMEZONE}).split(',')[0];
  return 'm3u_quota_' + parts; // e.g. m3u_quota_2025-10-30
}
function getQuotaUsage(){
  const key = quotaKeyForToday();
  const raw = localStorage.getItem(key);
  if(!raw) return 0;
  try{ const v = JSON.parse(raw); return v.used || 0; }catch(e){ return 0; }
}
function addQuotaUsage(amount){
  const key = quotaKeyForToday();
  const cur = getQuotaUsage();
  localStorage.setItem(key, JSON.stringify({date: new Date().toISOString(), used: cur + amount}));
  updateQuotaDisplay();
}
function getQuotaRemaining(){ return Math.max(0, DAILY_QUOTA - getQuotaUsage()); }

function updateQuotaDisplay(){
  const used = getQuotaUsage();
  const remaining = Math.max(0, DAILY_QUOTA - used);
  const batchSize = Number(batchSizeSelect.value || 10);
  const perSongEstimate = INSERT_COST + (SEARCH_COST / batchSize);
  const estSongs = Math.floor((remaining - PLAYLIST_COST) / perSongEstimate);

   // reset countdown to midnight CTD, I genuenly have no clue when it resets so I picked CDT
  const nowCTD = new Date(new Date().toLocaleString('en-US',{timeZone:CTD_TIMEZONE}));
  const reset = new Date(nowCTD);
  reset.setHours(24,0,0,0);
  const ms = reset - nowCTD;
  const hrs = Math.floor(ms/3600000);
  const mins = Math.floor((ms%3600000)/60000);

  quotaInfoEl.innerHTML = `<strong>Quota usage</strong>: ${used} / ${DAILY_QUOTA} units &nbsp; &middot; &nbsp; <strong>â‰ˆ ${Math.max(0,estSongs)}</strong> songs remaining today<br><span class="muted">Resets in ${hrs}h ${mins}m (midnight CTD)</span>`;
}
updateQuotaDisplay();

// ---------------- M3U parsing ----------------
function parseM3U(text, trimSegments){
  const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  const tracks = [];
  for(const line of lines){
    if(line.startsWith('#')) continue;
    let query = line;
    if(trimSegments>0){
      const parts = line.split(/\\\\|\//).filter(Boolean);
      if(parts.length>trimSegments) query = parts.slice(trimSegments).join(' '); else query = parts.join(' ');
    }
    query = query.replace(/\.[a-z0-9]{2,5}$/i,'').replace(/[\_\-\(\)\[\]"']+/g,' ').replace(/\s+/g,' ').trim();
    if(query) tracks.push({orig:line, query});
  }
  const seen = new Set(); const unique = [];
  for(const t of tracks){ if(!seen.has(t.query)){ seen.add(t.query); unique.push(t); } }
  return unique;
}

parseBtn.addEventListener('click', async ()=>{
  const f = fileInput.files[0];
  if(!f){ alert('Choose an m3u file first'); return; }
  const txt = await f.text();
  parsedTracks = parseM3U(txt, Number(trimSegmentsEl.value||0));
  renderTracks();
  saveSettings();
  createPlaylistBtn.disabled = parsedTracks.length===0 || !clientIdInput.value;
  log('Parsed', parsedTracks.length, 'tracks');
});

function renderTracks(){
  tracksCountEl.textContent = parsedTracks.length + ' tracks';
  const max = Math.min(parsedTracks.length, 200);
  let html = '<table><tr><th>#</th><th>Original</th><th>Query</th></tr>';
  for(let i=0;i<max;i++){ const t = parsedTracks[i]; html += `<tr><td>${i+1}</td><td>${escapeHtml(t.orig)}</td><td>${escapeHtml(t.query)}</td></tr>`; }
  html += '</table>';
  tracksArea.innerHTML = html + (parsedTracks.length>max?`<div class="muted">...and ${parsedTracks.length-max} more</div>`:'');
}

function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',"'":'&#39;'}[c])); }

// ---------------- Google OAuth ----------------
function requestAccessToken(){
  clientId = clientIdInput.value.trim();
  apiKey = apiKeyInput.value.trim();
  if(!clientId){ alert('Please paste your OAuth Client ID first'); return Promise.reject(new Error('no client id')); }
  saveSettings();
  return new Promise((resolve,reject)=>{
    if(accessToken) return resolve(accessToken);
    if(!window.google || !window.google.accounts || !window.google.accounts.oauth2){
      const s = document.createElement('script'); s.src = 'https://accounts.google.com/gsi/client';
      s.onload = () => initTokenClient(resolve,reject);
      s.onerror = (e)=>reject(new Error('Failed to load Google Identity script'));
      document.head.appendChild(s);
    }else initTokenClient(resolve,reject);
  });
}
function initTokenClient(resolve,reject){
  try{
    tokenClient = google.accounts.oauth2.initTokenClient({
      client_id: clientId,
      scope: 'https://www.googleapis.com/auth/youtube.force-ssl',
      callback: (resp) => {
        if(resp.error) return reject(new Error(resp.error_description || resp.error));
        accessToken = resp.access_token;
        log('Authorized â€” token acquired');
        resolve(accessToken);
      }
    });
    tokenClient.requestAccessToken();
  }catch(e){ reject(e); }
}

authorizeBtn.addEventListener('click', async ()=>{
  try{ await requestAccessToken(); createPlaylistBtn.disabled = parsedTracks.length===0; }catch(e){ log('Auth error', e && e.message?e.message:e); }
});

// ---------------- YouTube utils (batch search + insertion) ----------------
async function batchSearch(queries){
  // queries: array of strings, length = batchSize
  // Build OR query that includes each query in quotes where possible.
  const q = queries.map(s=>`"${s.replace(/"/g,'') }"`).join(' OR ');
  const maxResults = Math.min(50, queries.length * 4); // let API return multiple candidate per query
  const base = 'https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&maxResults=' + maxResults + '&q=' + encodeURIComponent(q);
  const url = apiKey ? base + '&key=' + apiKey : base;
  const headers = apiKey ? {} : { Authorization: 'Bearer ' + accessToken };
  const res = await fetch(url, { headers });
  const txt = await res.text();
  if(!res.ok){ log('YT search failed', tryParseJson(txt)); return {error: tryParseJson(txt)}; }
  addQuotaUsage(SEARCH_COST);
  const data = tryParseJson(txt);
  return {items: data.items || []};
}

function tryParseJson(txt){ try{ return JSON.parse(txt); }catch(e){ return txt; } }

function normalize(s){ return s.toLowerCase().replace(/[^a-z0-9\s]/g,' ').replace(/\s+/g,' ').trim(); }

function pickBestMatchForQuery(query, items){
  const nq = normalize(query);
  // rank items by simple score: overlap of words in title+channel
  let best = null; let bestScore = 0;
  for(const it of items){
    const title = (it.snippet && it.snippet.title) ? normalize(it.snippet.title) : '';
    const channel = (it.snippet && it.snippet.channelTitle) ? normalize(it.snippet.channelTitle) : '';
    const combined = (title + ' ' + channel).trim();
    if(!combined) continue;
    // compute word overlap
    const words = nq.split(' ');
    let score = 0;
    for(const w of words){ if(w.length>1 && combined.includes(w)) score += 1; }
    // prefer exact phrase in title
    if(title.includes(nq)) score += 3;
    if(score > bestScore){ bestScore = score; best = it; }
  }
  // threshold to avoid wildly incorrect picks
  if(bestScore >= Math.max(2, Math.floor(nq.split(' ').length/2))) return best.id && best.id.videoId ? best.id.videoId : null;
  return null;
}

async function findMatchesForBatch(batchQueries){
  const r = await batchSearch(batchQueries);
  if(r.error) return {error: r.error};
  const items = r.items || [];
  const res = {};
  for(const q of batchQueries){
    const cached = checkCache(q);
    if(cached) { res[q] = cached; continue; }
    const vid = pickBestMatchForQuery(q, items);
    if(vid){ putCache(q, vid); res[q] = vid; }
    else res[q] = null;
  }
  return res;
}

async function createPlaylist(title){
  const url = 'https://www.googleapis.com/youtube/v3/playlists?part=snippet%2Cstatus';
  const body = { snippet: { title, description: 'Imported from M3U' }, status: { privacyStatus: privacySelect.value } };
  const res = await fetch(url, { method: 'POST', headers: { 'Authorization': 'Bearer ' + accessToken, 'Content-Type': 'application/json' }, body: JSON.stringify(body)});
  const txt = await res.text();
  if(!res.ok){ const parsed = tryParseJson(txt); const err = parsed?.error?.message || txt; throw new Error('createPlaylist failed: ' + err); }
  addQuotaUsage(PLAYLIST_COST);
  const data = tryParseJson(txt);
  return data.id;
}

async function addVideoToPlaylist(playlistId, videoId){
  const url = 'https://www.googleapis.com/youtube/v3/playlistItems?part=snippet';
  const body = { snippet: { playlistId, resourceId: { kind: 'youtube#video', videoId } } };
  const res = await fetch(url, { method:'POST', headers: { 'Authorization':'Bearer ' + accessToken,'Content-Type':'application/json' }, body: JSON.stringify(body) });
  const txt = await res.text();
  if(!res.ok){ const parsed = tryParseJson(txt); log('addVideo failed', parsed); throw new Error('addVideo failed: ' + (parsed?.error?.message || txt)); }
  addQuotaUsage(INSERT_COST);
  return tryParseJson(txt);
}

// ---------------- Cache utils ----------------
function putCache(query, videoId){
  try{
    const cache = loadCache();
    cache[query] = { id: videoId, ts: Date.now() };
    saveCache(cache);
  }catch(e){ }
}
function checkCache(query){
  try{
    const cache = loadCache();
    const rec = cache[query];
    if(!rec) return null;
    const lifetimeDays = Number(cacheLifetimeSelect.value || 7);
    if(lifetimeDays>0){
      const ageDays = (Date.now() - rec.ts)/(1000*60*60*24);
      if(ageDays > lifetimeDays){ delete cache[query]; saveCache(cache); return null; }
    }
    return rec.id;
  }catch(e){ return null; }
}

// ---------------- Main flow ----------------
createPlaylistBtn.addEventListener('click', async ()=>{
  try{
    saveSettings();
    clientId = clientIdInput.value.trim(); apiKey = apiKeyInput.value.trim();
    if(!clientId){ alert('Paste your OAuth Client ID first'); return; }
    if(!accessToken) await requestAccessToken();
    if(parsedTracks.length===0){ alert('No parsed tracks'); return; }

    const title = prompt('Playlist title', 'Imported from M3U') || 'Imported from M3U';
    progressEl.textContent = 'Creating playlist...';
    const playlistId = await createPlaylist(title);
    log('Playlist created', playlistId);

    const batchSize = Number(batchSizeSelect.value||10);
    let added = 0; let notFound = [];
    // process in batches
    for(let i=0;i<parsedTracks.length;i+=batchSize){
      const batch = parsedTracks.slice(i, i+batchSize).map(t=>t.query);
      progressEl.textContent = `Searching batch ${Math.floor(i/batchSize)+1} (${i+1}-${Math.min(i+batchSize, parsedTracks.length)})`;
      const matches = await findMatchesForBatch(batch);
      if(matches.error){ log('Batch search error', matches.error); if(matches.error?.error?.code===403 && matches.error?.error?.errors?.[0]?.reason==='quotaExceeded'){ log('Quota exhausted â€” stopping.'); break; } }
      // add found videos to playlist
      for(const q of batch){
        const vid = matches[q];
        if(vid){
          try{ await addVideoToPlaylist(playlistId, vid); added++; log('Added', q, '->', vid); }
          catch(e){ log('Failed to add', q, e && e.message?e.message:e); }
        }else{ notFound.push(q); log('Not found (batch):', q); }
        // small delay to avoid bursts
        await new Promise(r=>setTimeout(r, 200));
      }
      updateQuotaDisplay();
      // if remaining quota is too low to continue safely, stop
      if(getQuotaRemaining() < INSERT_COST + Math.ceil(SEARCH_COST / batchSize)){ log('Low quota â€” stopping early.'); break; }
    }

    log('Done. Added: ' + added + ' Not found: ' + notFound.length);
    if(notFound.length) log('Not found list:\n' + notFound.join('\n'));
    progressEl.textContent = 'Completed';
  }catch(e){
    log('Error during playlist creation', e && e.message?e.message: e);
    progressEl.textContent = 'Error';
  }
});

// ---------------- small stuff ----------------
clientIdInput.addEventListener('change', saveSettings);
apiKeyInput.addEventListener('change', saveSettings);
batchSizeSelect.addEventListener('change', ()=>{ saveSettings(); updateQuotaDisplay(); });
cacheLifetimeSelect.addEventListener('change', saveSettings);
privacySelect.addEventListener('change', saveSettings);

// initial render
renderTracks(); updateQuotaDisplay();

// show console errors to user via alert once so they notice
window.addEventListener('error', (ev)=>{ console.error(ev); /* don't alert to avoid spam */ });

</script>
</body>
</html>
